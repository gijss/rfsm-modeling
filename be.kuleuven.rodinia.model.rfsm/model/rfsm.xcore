@Ecore(invocationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot",
settingDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")

package be.kuleuven.rodinia.model.rfsm

annotation "http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot" as Pivot

/*
 * This Xcore metamodel started as an extension of the Ecore metamodel in the rFSM paper
 */
 
//the introduction of rootnode makes it easier to implement the 'only on root node constraint'
//other possibility is to set Node to accept State[0..1] parent and to add a constraint that only one node has no parent
//@Ecore(constraints="onlyOneRootNode")
//There is only one node that has no parent (ie: root node)
//@Pivot(onlyOneRootNode="RootNode.allInstances()->size() = 1")
//class RootNode {
//	String name
//}
 
@Ecore(constraints="onlyOneRootNode")
//There is only one node that has no parent (ie: root node)
@Pivot(onlyOneRootNode="(Node.allInstances()->select(n | n.parent.oclIsUndefined ()))->size() = 1")
class Node {
	String name
	container State[0..1] parent opposite subnodes
}

@Ecore(constraints="defineInitialConnector defineMaxOneInitialConnector")
//Each composite state that is target of a transition, defines an initial connector.
@Pivot(defineInitialConnector="self.subnodes->size() > 0 and Transition.allInstances()->select(t | t.target=self)->size() >= 1 implies (self.subnodes->select(c | c.oclIsTypeOf(Connector) and c.name='initial'))->size() = 1")
//A composite state may define at most one initial connector.
@Pivot(defineMaxOneInitialConnector="self.subnodes->size() > 0 implies (self.subnodes->select(c | c.oclIsTypeOf(Connector) and c.name='initial'))->size() <= 1")
class State extends Node {
	contains Transition[] transitions opposite owner
	contains Node[] subnodes opposite parent
	contains Function[0..1] entry	//contains function in this example (original:refers)
	contains Function[0..1] doo	//contains function in this example (original:refers)
	contains Function[0..1] exit	//contains function in this example (original:refers)
}

class Connector extends Node {
	boolean public
	contains History[0..1] history
}

@Ecore(constraints="transitionOwner")
//Transitions are owned by composite states and not, as often assumed, by the states from which they originate
//todo: needs helper operations like least-common-ancestor
@Pivot(transitionOwner="priority_number <> -1") //example
class Transition {
	int priority_number = "0"
	container State[1] owner opposite transitions
	contains Event[] events	opposite owner//possible to add this logic to the guard function
	contains Function[0..1] guard	//contains function in this example (original:refers)
	contains Function[0..1] effect	//contains function in this example (original:refers)
	refers Node[1] source
	refers Node[1] target
	
	//is one ancestor of two?
	@Pivot(body="if (two.parent = null)
				then false
				else if (two.parent = one)
					then true
					else isAncestor(one, two.parent)
					endif
				endif;")
	op Boolean isAncestor(State one, State two)
	
	//calculate least common ancestor of node one and two
	@Pivot(body="")
	op State LCA(Node one, Node two)
}

//possible to add this logic to the guard function
class Event {
	String eventliteral
	container Transition owner opposite events
}

class Function {
	String sourcecode
}

class History {
	int depth
	boolean hot
}