@Ecore(invocationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot",
settingDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")

package be.kuleuven.rodinia.model.rfsm

annotation "http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot" as Pivot

/*
 * This xcore started as a transformation of the ecore model in the rfsm paper
 */
 
class Node {
	String name	
	container State[1] parent opposite subnodes	//shouldn't this be State[0..1]? (root node doesn't have parent)
}

@Ecore(constraints="definitconn, onlyoneinitconn")
//Enforce that each composite state that is target of a transition, defines an initial connector.
@Pivot(definitconn="self.subnodes->size() > 0 and Transition.allInstances()->select(t | t.target=self)->size() >= 1 implies (self.subnodes->select(c | c.oclIsTypeOf(Connector) and c.name='initial'))->size() = 1")
//A composite state may define at most one initial connector.
@Pivot(onlyoneinitconn="self.subnodes.size > 0 implies (self.subnodes()->select(c | c.isTypeOf(Connector) and c.name='initial'))->size() <= 1")

class State extends Node {
	contains Transition[] transitions opposite owner
	contains Node[] subnodes opposite parent
	refers Function[0..1] entry
	refers Function[0..1] doo
	refers Function[0..1] exit
}

class Connector extends Node {
	boolean public
	contains History[0..1] history
}

@Ecore(constraints="test")
//Transitions are owned by composite states and not, as often assumed, by the states from which they originate
@Pivot(test="priority_numbers <> 0")
class Transition {
	int priority_numbers
	container State[1] owner opposite transitions
	refers Function[0..1] guard
	refers Function[0..1] effect
	refers Node[1] source
	refers Node[1] target
}

class Function {
	String luacode
}

class History {
	int depth
	boolean hot
}