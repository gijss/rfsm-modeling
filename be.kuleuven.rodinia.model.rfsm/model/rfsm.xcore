@Ecore(invocationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot",
settingDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")

package be.kuleuven.rodinia.model.rfsm

annotation "http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot" as Pivot

/*
 * This Xcore metamodel started as an extension of the Ecore metamodel in the rFSM paper
 */
 
@Ecore(constraints="defineOnlyOneRootNode")
//There is only one node that has no parent (ie: root node),
//a rFSM model is always contained within a state
@Pivot(defineOnlyOneRootNode="(Node.allInstances()->select(n | n.parent.oclIsUndefined ()))->size() = 1")
class Node {
	String name
	container State[0..1] parent opposite subnodes
}

@Ecore(constraints="defineInitialConnectorWhenComposite defineMaxOneInitialConnector onlyLeafStatesHaveDoo")
//Each composite state that is target of a transition, defines an initial connector.
@Pivot(defineInitialConnectorWhenComposite="self.subnodes->size() > 0 and Transition.allInstances()->exists(t | t.target=self) implies self.subnodes->select(c | c.oclIsTypeOf(Connector) and c.name='initial'))->size() = 1")
//A composite state may define at most one initial connector.
@Pivot(defineMaxOneInitialConnector="self.subnodes->size() > 0 implies (self.subnodes->select(c | c.oclIsTypeOf(Connector) and c.name='initial'))->size() <= 1")
//Only leaf-states can define a doo function. (not sure about this one)
@Pivot(onlyLeafStatesHaveDoo="(not self.doo.oclIsUndefined()) implies (self.subnodes->size() = 0)")
class State extends Node {
	contains Transition[] transitions opposite owner
	contains Node[] subnodes opposite parent
	contains Function[0..1] entry	//contains function in this example (original:refers)
	contains Function[0..1] doo	//contains function in this example (original:refers)
	contains Function[0..1] exit	//contains function in this example (original:refers)
}

class Connector extends Node {
	boolean public
	contains History[0..1] history
}

@Ecore(constraints="transitionOwner")
//Transitions are owned by composite states and not by the states from which they originate
//It is required that transitions are owned by no state less nested than the transition LCA
//todo: needs helper operations like least-common-ancestor
@Pivot(transitionOwner="priority_number <> -1") //example
class Transition {
	//todo: set default priority_number according to position in model tree
	int priority_number = "0"
	container State[1] owner opposite transitions
	contains Event[] events	opposite owner	//possible to add this logic to the guard function
	contains Function[0..1] guard	//contains function in this example (original:refers)
	contains Function[0..1] effect	//contains function in this example (original:refers)
	refers Node[1] source
	refers Node[1] target
	
	//is one ancestor of two?
	@Pivot(body="if (two.parent.oclIsUndefined ())
				then false
				else if (two.parent = one)
					then true
					else isAncestor(one, two.parent)
					endif
				endif;")
	op Boolean isAncestor(State one, State two)
	
	//calculate least common ancestor of node one and two
	@Pivot(body="")
	op State LCA(Node one, Node two)
}

//possible to add this logic to the guard function, which would be more generic
//this simple event-trigger-language is based on the Lua rFSM implementation
class Event {
	String eventliteral
	container Transition owner opposite events
}

//todo: use Lua grammar to parse function
class Function {
	String sourcecode
}

//how to model history behaviour?
class History {
	int depth
	boolean hot
}

//Behavioral constraints:
//exactly one leaf state is active and if a state is active, its parent is active too; so the set of active states is always transitively closed with respect to the parent relation.
//The higher the source state of a transition is located in the state machineâ€™s tree, the higher the priority of the transition.
//as soon as an enabled transition is found, the searching terminates and the transition is executed
